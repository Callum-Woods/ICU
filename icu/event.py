import time
import copy
from types import SimpleNamespace

from multiprocessing import Queue

global finish
finish = False

# create unique event ids (ids do not reflect time)
EVENT_NAME = 0
def next_name():
    global EVENT_NAME
    EVENT_NAME += 1
    return str(EVENT_NAME)

class Event:

    def __init__(self, src, dst, timestamp=None, **data):
        super(Event, self).__init__()
        self.name = next_name()
        self.dst = dst
        self.src = src
        self.data = SimpleNamespace(**data)
        self.timestamp = timestamp
        if timestamp is None:
            self.timestamp = time.time()

    def __str__(self):
        return "{0}:{1} - ({2}->{3}): {4}".format(self.name, self.timestamp, self.src, self.dst, self.data.__dict__)

    def to_tuple(self):
        return (self.timestamp, self.name, (self.src, self.dst), copy.deepcopy(self.data.__dict__))


class ExternalEventSource: 
    """ 
        A thread-safe event source to be used externally as a
        mechanism for sending events to the ICU system.
    """

    def __init__(self, *args, **kwargs):
        super(ExternalEventSource, self).__init__(*args, **kwargs)
        self.__buffer = Queue()
    
    def source(self, src, dst, timestamp=None, **data):
        """
            Send a new event to the ICU system.
        
        Args:
            src (str): the name of the source object (a unique ID)
            dst (str): the name of the destination (sink) object (a unique ID), see get_event_sources() for a list of source IDs.
            timestamp (float, optional): floating point number expressed in seconds since the epoch, in UTC (see time.time()). Defaults to the current time (on event instantiation).
        """
        self.__buffer.put(Event(src, dst, timestamp=timestamp, **data))

    def empty(self):
        return self.__buffer.empty()

    def size(self):
        return self.__buffer.qsize()

    def close(self):
        return self.__buffer.close()

class ExternalEventSink:

    """
        A thread-safe event sink to be used externally as a 
        mechanism for receiving events from the ICU system.
    """
    def __init__(self, *args, **kwargs):
        super(ExternalEventSink, self).__init__(*args, **kwargs)
        self.__buffer = Queue()
    
    def get(self):
        '''
            Pop from event buffer.
        '''
        return self.__buffer.get()

    def full(self):
        return self.__buffer.full()

    def empty(self):
        return self.__buffer.empty()

    def size(self):
        return self.__buffer.qsize()

    def close(self):
        return self.__buffer.close()

#EVENT_SINKS = {}
#EVENT_SOURCES = {}
    
class GlobalEventCallback:

    def __init__(self):

        self.external_sinks = []
        self.external_sources = []

        self.sinks = {}
        self.sources = {}

    def trigger(self, event):
        if event is not None:
            if event.dst in self.sinks:
                self.sinks[event.dst].sink(event)
            self.__sink_external(event) #send to all external sinks
            #print(event)

    def __sink_external(self, event): # TODO this could be changed at some point... a more advanced event system is needed
        for sink in self.external_sinks:
            sink._ExternalEventSink__buffer.put(copy.deepcopy(event))

    def register_sink(self, name, sink):
        self.sinks[name] = sink
    
    def register_source(self, name, source):
        self.sources[name] = source

    def add_external_event_source(self, source):
        assert isinstance(source, ExternalEventSource)
        self.external_sources.append(source)

    def add_external_event_sink(self, sink):
        assert isinstance(sink, ExternalEventSink)
        self.external_sinks.append(sink)

# ===  GLOBAL === #
GLOBAL_EVENT_CALLBACK = GlobalEventCallback()
global event_scheduler
event_scheduler = None

def get_event_sources():
    return list(GLOBAL_EVENT_CALLBACK.sources.keys())

def get_event_sinks():
    return list(GLOBAL_EVENT_CALLBACK.sinks.keys())

def get_external_event_sinks():
    return GLOBAL_EVENT_CALLBACK.external_sinks

def get_external_event_sources():
    return GLOBAL_EVENT_CALLBACK.external_sources

def add_event_source(source):
    '''
        Add an external event source to ICU. Any events generated by 
        this source will be propagated to an ICU event sink.
    '''
    GLOBAL_EVENT_CALLBACK.add_external_event_source(source)

def add_event_sink(sink):
    '''
        Add an external event sink to ICU. This event sink will receive 
        all events that are generated by the ICU system.
    '''
    GLOBAL_EVENT_CALLBACK.add_external_event_sink(sink)

#TODO function for removing external event_source/sink? 

# ============ INTERNAL ============ #

class EventCallback:
    '''
        Used internally by widgets that can receive and generate events.
    '''

    def __init__(self, *args, **kwargs):
        super(EventCallback, self).__init__(*args, **kwargs)

    def register(self, name):
        self.__name = "{0}:{1}".format(type(self).__name__, name)
        GLOBAL_EVENT_CALLBACK.register_sink(self.__name, self)
        GLOBAL_EVENT_CALLBACK.register_source(self.__name, self)

    def source(self, dst, timestamp=None, **data):
        e = Event(self.name, dst, timestamp=timestamp, **data)
        global event_scheduler
        event_scheduler.schedule(e, sleep=0)

    def sink(self, event): #override this method
        pass

    @property
    def name(self):
        return self.__name

def sleep_repeat_int(sleep):
    while True:
        yield sleep

def sleep_repeat_list(sleep):
    while True:
        for i in sleep:
            yield i

class TKSchedular: #might be better to detach events from the GUI? quick and dirty for now...

    def __init__(self, tk_root):
        self.tk_root = tk_root

    def schedule(self, generator, sleep=0):
        if isinstance(sleep, float):
            sleep = int(sleep)

        if isinstance(generator, Event):
            assert isinstance(sleep, int)
            self.after(sleep, GLOBAL_EVENT_CALLBACK.trigger, generator)
            return

        if isinstance(sleep, int):
            sleep = sleep_repeat_int([sleep]) #TODO refactor
        elif isinstance(sleep, (list,tuple)):
            sleep = sleep_repeat_list(sleep)

        #repeated event
        self.after(next(sleep), self.__trigger_repeat, generator, sleep)

    def __trigger_repeat(self, generator, sleep):
        try:
            GLOBAL_EVENT_CALLBACK.trigger(next(generator))
        except StopIteration:
            pass
        try:
            self.after(next(sleep), self.__trigger_repeat, generator, sleep)
        except StopIteration:
            pass 

    def after(self, sleep, fun, *args):
        self.tk_root.after(sleep, fun, *args)

def tk_event_schedular(root):
    global event_scheduler
    event_scheduler = TKSchedular(root)